# -*- coding: utf-8 -*-
"""Python Training.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vGUmDQUSkhbFExmkBGsj7cNwTj6WSjYR
"""

#variable -> data containner 
_a_="Hello" #string -> anything written in single or double quote is know as string
a= 123 #int ->  integer is a number as all whole numbers
A= 135.23 #float -> all decimal numbers are float
a1= True #boolean -> it says wheather the statement True or False 
print(_a_)

name='Mike'
print(name)
print(type(name)) #type() -> used to say that which data type variable contained by variable
num1=4743
print(type(num1))

print(10>9) #boolean -> give the statement true or false
print(154>687)

#collection data types
'''
List 
Set
Tupple
Dictionaries
'''

#List is an ordered collection datatypes, uses [] brackets, list is an mutable #mutable know as we change data whenever we want  in the  list (mutable means changable)
mylist=["mike","nike","nik","hike",132,True]
print(mylist)
print(type(mylist))
#positive indexing
print(mylist[0]) #[0] contains the datatype in the 0th position  index of the mylist (which is first datatype of the mylist)
#negative indexing
print(mylist[-1]) #(which is last datatype of the mylist)

"""**Class2**"""

mylist=["mike","nike","nik","hike",132,True]
print(mylist)
#Updating list as known as mutable
mylist[5]=False
print(mylist)

# append() method is used to add the data  at the end of  the list 
mylist.append(132.54)
print(mylist)
# insert(x,y) method is used to add the data in specific position in the list x-> is the position you want to add the data; y -> data you want to add
mylist.insert(3,"hope")
print(mylist)

#extend() method is used to insert one list in another
a= [1,3,123,23,36,2,32]
b= [302,343,34,434,39,86,8]
a.extend(b)
print(a)
#to add  data at pacific index use insert() function
mylist.insert(2,'rebacca')
print(mylist)

"""**class 2**

"""

#to add  data at pacific index use insert() function
mylist.insert(2,'rebacca')
print(mylist)

for x in mylist:
  print(type(x))

for y in mylist:
  print(y)

"""what is class?
class is an template defination of methods and variables in the particular kind of object. object is an special instance of the class which contains real values instead of variables.

collective datatypes are:
1)list
2)tuple
3)set
4)dictionary

**list->collection of data, ordered and mutable and list is denoted by []**

mylist=['Data','task','mike','a']

**whenever a variable contents same data-type those are called as homogeneous in mylist you see that all the objects of list are Strings  **

mylist1=['Data','task','mike','a',13,23.423,True]

**when a variable contents different data-type those are called as hetrogeneous in mylist1 you see that all the objects of list are different i.e contains (string,int,float,boolean)  **
"""

mylist=['Data','task','mike','a']
print('It is a Homogeneous:', mylist)
mylist1=['Data','task','mike','a',13,23.423,True]
print('It is a Hetrogeneous:', mylist1)
print(type(mylist))
type(mylist)

"""**Index value-> which will help us to print Individual data of the collective datatypes**

**Mutable-> means changeable, so we can change the data of the list by #update function by using index symbol**

**append() funtion is to add the new data objects to the list at end of the list**

**insert() function is used to add the new data object tgo the list at specific index of the list i.e at particular place in the list**

**extend() function is used add two  list**

**remove() funtion is used to remove the data object of the list**

**del() function is used to delete  data object and the entire list at a time**
"""

print(mylist1[0])
print(mylist1[1])
print(mylist1[2])
print(mylist1[3])
print(mylist1[4])
print(mylist1[5])
print(mylist1[6])

from re import M
#upadate function
mylist1=['Data','task','mike','a',13,23.423,True]
mylist1[6]=False
print(mylist1)

#extend
mylist2=[1,2,3,4]
mylist1.extend(mylist2)
print(mylist1)

#remove
mylist1.remove('a')
print(mylist1)

#delete
del mylist1[8]
print(mylist1)

del mylist1
print(mylist1)

"""**Tuple-> it is ordered collection of data  and its not mutable, denoted by ()**

**len() function is used to inform the lenght of the datatypes**

**Dictionary-> It is also a ordered collection of data type but the dta which you going to enter is in terms key and values and denoted by {}**

**In dictionary we can print the value of key by using a key in print statement and we can update the value by using a key**

**In Dictionary we can have multiple connetions of data like having list and tuple in dictionary**
"""

mydict={"user":"student",
        "password":12345678,
        "Batch":2023
        }
print(mydict)   
print(mydict["Batch"])  
#update
mydict["password"]=5949
print(mydict)
mydict["Batch"]=(2022,2023)
print(mydict)
mydict["course"]="Python"
print(mydict)

import tkinter as tk
import tkinter.messagebox
import time


class Application(tk.Frame): 
    def __init__(self, master, *args, **kwargs):
        tk.Frame.__init__(self, master, *args, **kwargs)
        self.master = master
        self.running = False
        self.time = 0
        self.hours = 0
        self.mins = 0
        self.secs = 0
        self.build_interface()

    def build_interface(self):
        self.time_entry = tk.Entry(self)
        self.time_entry.grid(row=0, column=1)

        self.clock = tk.Label(self, text="00:00:00", font=("Courier", 20), width=10)
        self.clock.grid(row=1, column=1, stick="S")

        self.time_label = tk.Label(self, text="hour   min   sec", font=("Courier", 10), width=15)
        self.time_label.grid(row=2, column=1, sticky="N")

        self.power_button = tk.Button(self, text="Start", command=lambda: self.start())
        self.power_button.grid(row=3, column=0, sticky="NE")

        self.reset_button = tk.Button(self, text="Reset", command=lambda: self.reset())
        self.reset_button.grid(row=3, column=1, sticky="NW")

        self.quit_button = tk.Button(self, text="Quit", command=lambda: self.quit())
        self.quit_button.grid(row=3, column=3, sticky="NE")

        self.pause_button = tk.Button(self, text="Pause", command=lambda: self.pause())
        self.pause_button.grid(row = 3,column=2, sticky = "NW")

        self.master.bind("<Return>", lambda x: self.start())
        self.time_entry.bind("<Key>", lambda v: self.update())

    def calculate(self):
        """time calculation"""
        self.hours = self.time // 3600
        self.mins = (self.time // 60) % 60
        self.secs = self.time % 60
        return "{:02d}:{:02d}:{:02d}".format(self.hours, self.mins, self.secs)

    def update(self):
        """validation"""
        self.time = int(self.time_entry.get())
        try:
            self.clock.configure(text=self.calculate())
        except:
            self.clock.configure(text="00:00:00")

    def timer(self):
        """display time"""
        if self.running:
            if self.time <= 0:
                self.clock.configure(text="Time's up!")
            else:
                self.clock.configure(text=self.calculate())
                self.time -= 1
                self.after(1000, self.timer)

    def start(self):
        """start timer"""
        try:
            self.time = int(self.time_entry.get())
            self.time_entry.delete(0, 'end')
        except:
            self.time = self.time
        self.power_button.configure(text="Stop", command=lambda: self.stop())
        self.master.bind("<Return>", lambda x: self.stop())
        self.running = True
        self.timer()

    def stop(self):
        """Stop timer"""
        self.power_button.configure(text="Start", command=lambda: self.start())
        self.master.bind("<Return>", lambda x: self.start())
        self.running = False

    def reset(self):
        """Resets the timer to 0."""
        self.power_button.configure(text="Start", command=lambda: self.start())
        self.master.bind("<Return>", lambda x: self.start())
        self.running = False
        self.time = 0
        self.clock["text"] = "00:00:00"

    def quit(self):
        """quit the window"""
        if tk.messagebox.askokcancel("Quit", "Do you want to quit?"):
            root.destroy()

    def pause(self):
        """Pause timer"""
        self.pause_button.configure(text="Resume", command=lambda: self.resume())
        self.master.bind("<Return>", lambda x: self.resume())
        if self.running == True:
            self.running = False
        self.timer()
      

    def resume(self):
        """Resume timer"""
        self.pause_button.configure(text="Pause", command=lambda: self.pause())
        self.master.bind("<Return>", lambda x: self.pause())
        if self.running == False:
            self.running = True
        self.timer()
       

            


if __name__ == "__main__":
    """Main loop of timer"""
    root = tk.Tk()
    root.title("TIMER")
    Application(root).pack(side="top", fill="both", expand=True)
    root.mainloop()

# import the time module
import time

# define the countdown func.
def countdown(t):
	
	while t:
		mins, secs = divmod(t, 60)
		timer = '{:02d}:{:02d}'.format(mins, secs)
		print(timer, end="\r")
		time.sleep(1)
		t -= 1
	
	print('Fire in the hole!!')


# input time in seconds
t = input("Enter the time in seconds: ")

# function call
countdown(int(t))

import time

class CountdownTimer:

   def __init__(self, duration):

       self.duration = duration

       self.start_time = None

       self.elapsed_time = 0

       self.paused = False

   def start(self):

       self.start_time = time.time()

   def reset(self):

       self.start_time = None

       self.elapsed_time = 0

   def stop(self):

       self.start_time = None

       self.elapsed_time = 0

       self.paused = False

   def pause(self):

       if self.start_time is not None and not self.paused:

           self.elapsed_time += time.time() - self.start_time

           self.start_time = None

           self.paused = True

   def resume(self):

       if self.start_time is None and self.paused:

           self.start_time = time.time()

           self.paused = False

   def get_time_left(self):

       if self.start_time is None:

           return self.duration - self.elapsed_time

       else:

           return self.duration - (time.time() - self.start_time + self.elapsed_time)

   def is_finished(self):

       return self.get_time_left() <= 0

#Example usage

timer = CountdownTimer(60)

timer.start()

while not timer.is_finished():

   time_left = timer.get_time_left()

   print(f"Time left: {time_left:.1f} seconds")

   time.sleep(0.5)

   # Pause timer after 30 seconds

   if time_left <= 30 and not timer.paused:

       print("Pausing timer...")

       timer.pause()

   # Resume timer after 5 seconds

   if time_left <= 25 and timer.paused:

       print("Resuming timer...")

       timer.resume()

   # Reset timer after 50 seconds

   if time_left <= 10:

       print("Resetting timer...")

       timer.reset()

print("Timer finished!")

x = [-1, 0, 1][-1]
print(x)

a =7
b = 5
print(str(a) + str(b))

#set -> unordered collection of data and it will remove duplites before printint and we can't print indivisaul values in set because it is an unordered collection of data and its doesn't have fixed index value
myset={'data','task',23.32,64,78.34,64,25.34}
print(myset)
#add
myset.add('true')
print(myset)

# if you want ot combine two sets
set1={2,4,2,53,85,65}
set2={42,4,24,7,46,64}
set0={322,435,534,645,645}
set3=set1.union(set2)
print(set3)
set4=set1|set2|set0
print(set4)
set3=set1.intersection(set2)
print(set3)
set3=set1&(set2)
print(set3)
set3=set1.difference(set2)
print(set3)

# Function a set of data will be excuted whenever you call it 
# we are going to create a funtion by the help of 'def' keyword
def fun():
  print('Hello all \nwelcome back')
fun()

def add(a,b): #here a and b are parameter sof the function
  print(a+b,(a-b),a*b,a/b,a%b)
add(64,75)   # 64 and 75 are arugument of a and b

# for loop -> looping is nothing but printing the data one by one according to condition
x=8
for i in range(0,x):
  print(i)

myset={23,434,65,34}
for a in myset:
  print(a)

#GITHUB -> Version control system and we can work in a team 
#Encapsulation -> try to enclose something  or hide the data 
class abc():
  def __init__(a,name,weight):
    
    a.name=(name)
    a.weight=weight
  def showname(a):
    print(a.name)

#polymorphism -> poly means many and morp means forms totally it is known as (manyforms)
#object -> it is an instance of the class
mba1=abc("Asus",55)
mba1.showname()

